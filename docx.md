session 类本质上是一个自治的业务代理人 (Autonomous Agent)。 它的唯一任务是：接待一个客户端连接，搞清楚它想干什么，帮它办完事，然后销毁自己。

所有的接口都是围绕这个生命周期设计的。我们将它们分为四个阶段：

第一阶段：出生与启动 (Lifecycle)
1. explicit session(...) (构造函数)

它是干什么的？ 装配资源。

为什么要它？ 一个特工出门执行任务，必须带齐装备：

socket：用来和客户端说话的电话线。

ssl_ctx：用来和 Obscura 客户端加密通话的密码本（证书）。

distributor：用来寻找上游服务器的地图（路由/连接池）。

如果不传这些，Session 就是个废人，什么都干不了。

2. start()

它是干什么的？ 点火，启动协程。

为什么要它？

在 C++ 智能指针体系中，对象创建出来了 (new) 并不代表它开始工作了。

start() 的核心作用是调用 shared_from_this()，给自己续命。它告诉系统：“只要我的协程还没跑完，就算外面的 Worker 把我忘（释放）了，我也不能死。”

它将同步的代码逻辑转换为异步的后台任务 (net::co_spawn)。

3. close()

它是干什么的？ 清理现场，自我销毁。

为什么要它？

TCP 连接是操作系统的稀缺资源（文件描述符）。

不管任务成功还是失败，必须显式调用 close 挂断电话，否则服务器很快就会因为“占线”而无法接待新客（资源泄漏）。

第二阶段：安检与分流 (Detection & Decision)
4. diversion() (原 run_process)

它是干什么的？ 它是交通警察。

为什么要它？

你的服务器只开了一个端口（比如 8080），但要同时接待两种客人：普通浏览器 (HTTP) 和 你的私有客户端 (Obscura)。

它们说的语言不一样。如果盲目解析，肯定报错。

所以必须有一个步骤，偷看 (Peek) 客户端发来的前几个字节（比如看是 "GET" 还是 "0x16"），然后决定把客人指引到哪个房间（handle_http 还是 handle_obscura）。

第三阶段：业务处理 (Business Logic)
这是 Session 的大脑，根据分流结果进入不同逻辑。

5. handle_http()

它是干什么的？ 接待普通人（浏览器）。

为什么要它？

浏览器说话是明文的 HTTP。

它需要：读请求 -> 解析头部 -> 知道要去哪 (Resolve) -> 连接上游 (Route) -> 建立隧道。

如果是 HTTPS 代理，它还需要特殊处理 CONNECT 方法，回复一个 200 Connection Established，骗浏览器说“线接通了”。

6. handle_obscura()

它是干什么的？ 接待特工（Obscura 客户端）。

为什么要它？

Obscura 客户端说话是加密的 SSL。直接读是乱码。

它需要：SSL 握手 (Handshake) -> 解密 -> 读内部的目标地址 -> 连接上游 -> 建立加密隧道。

这个函数封装了所有复杂的解密和“黑话”对暗号的逻辑。

7. read_http_request()

它是干什么的？ 一个专门读 HTTP 包的苦力。

为什么要它？

TCP 是流式的，数据可能像挤牙膏一样一点点来。

必须有一个循环，不断读，直到读到 \r\n\r\n (头结束)，甚至还要读 Content-Length (体结束)。

没有它，可能请求还没读完，你就开始解析，导致报错。

第四阶段：数据搬运 (Data Tunneling)
这是 Session 的四肢，负责干苦力。一旦连接建立，就不需要动脑子了，只管搬砖。

8. tunnel_tcp()

它是干什么的？ 建立普通 TCP 双向管道。

为什么要它？

左手是客户端，右手是百度/谷歌。

它启动两个搬运工（协程）：一个把左边的数据搬到右边，一个把右边搬到左边。

它利用 && 运算符等待，只要有一边断了，就通知另一边停工。

9. tunnel_obscura(proto)

它是干什么的？ 建立带翻译的管道。

为什么要它？

和普通 TCP 不同，这根管道的一端（客户端）是加密的。

不能直接搬运，必须经过 proto 对象进行 解密 (Read) 和 加密 (Write)。

如果不分开写，普通 TCP 隧道处理不了 Obscura 的加解密逻辑。

10. transfer_... 系列函数

它是干什么的？ 真正的搬砖工。

为什么要它？

就是一个死循环：read -> write -> read -> write...

这是数据转发的最底层实现。

总结：为什么这么设计？
这是一种经典的 “状态机” (State Machine) 或 “责任链” 设计：

初始化 (session 构造)

启动 (start)

识别 (diversion)

协商 (handle_http / handle_obscura)

这里把要去哪搞清楚了。

转发 (tunnel_...)

这里开始真正干活。

销毁 (close)

每个接口都对应这个流水线上的一个环节。缺少任何一个，这个“代理人”就无法完成任务。