## 前置知识：读懂 ForwardEngine 需要知道什么

这份文档的目的：帮助第一次打开仓库的人，快速理解这个项目在做什么、关键概念是什么、主流程怎么走、为什么需要这些模块。

### 1. 这个项目解决什么问题

ForwardEngine 是一个基于 C++20 协程与 Boost.Asio 的代理引擎原型，目标是把“接入 → 协议识别 → 路由 → 上游连接 → 双向转发”这条链路跑通，并保留清晰的模块边界，便于后续演进。

你可以把它理解为一个会处理两类客户端的代理入口：

- 普通浏览器/代理客户端：走明文 HTTP，包含 `CONNECT` 场景（HTTPS 代理）。
- 私有客户端（Obscura）：走 WebSocket(SSL) 的“传输封装”，客户端把目标信息藏在握手阶段，再进入加密的双向转发。

### 2. 目录与模块对照

理解仓库最重要的两个目录：

- `include/forward-engine/*`：主要的对外接口与核心实现（大量 header-only）。
- `src/forward-engine/*`：部分模块的 `.cpp` 实现与可执行程序入口。

关键模块（建议按顺序看）：

- `agent/worker.hpp`：监听端口、accept 客户端连接、创建 `session`。
- `agent/session.hpp`：会话生命周期与主链路（协议识别、处理 HTTP/Obscura、建立隧道）。
- `agent/analysis.hpp/.cpp`：协议识别（peek）、目标解析（host/port/正反向判断等）。
- `agent/distributor.hpp/.cpp`：路由与连接获取（正向/反向/直连等策略入口）。
- `agent/connection.hpp/.cpp`：TCP 连接池与复用（缓存、僵尸检测、空闲超时、上限等）。
- `agent/obscura.hpp`：基于 Beast WebSocket(SSL) 的封装，提供 `handshake/async_read/async_write`。
- `agent/adaptation.hpp`：统一不同 socket/stream 的 `async_read/async_write` 适配层。
- `http/*`：HTTP request/response/header 类型与编解码。

### 3. 代理相关核心概念

#### 3.1 正向代理 vs 反向代理

- `正向代理`：客户端告诉代理“我要去哪里”（例如 `CONNECT host:port` 或普通 HTTP 请求行里包含目标信息）。代理负责“帮我连上目标并转发”。
- `反向代理`：客户端认为自己在访问一个固定域名/入口，代理根据内部路由表把请求转发到真实后端（通常需要配置映射表）。

在 ForwardEngine 里，这个分支由 `analysis::resolve` 的结果驱动：会决定走 `route_forward` 还是 `route_reverse`。

#### 3.2 HTTP `CONNECT` 是什么

`CONNECT` 是 HTTPS 代理的常见方式：

- 客户端先发 `CONNECT host:port HTTP/1.1 ...`，请求代理“建立到目标的 TCP 隧道”。
- 代理如果同意，会回 `HTTP/1.1 200 Connection Established\r\n\r\n`。
- 从这之后，双方就把这条 TCP 连接当作“纯字节流隧道”使用；代理不再解析 HTTP，而是做双向搬运。

#### 3.3 “隧道/双向转发”意味着什么

隧道阶段本质就是两个方向各跑一个循环：

- 客户端 → 上游：读客户端字节流，写到上游。
- 上游 → 客户端：读上游字节流，写回客户端。

难点不是“能不能转发”，而是“怎么正确退出”：

- 一边 EOF 了，另一边不能永远卡住。
- 一边异常了，另一边要尽快停工并回收资源。
- 不应把“正常断开”（EOF/取消/连接重置）误判为业务错误。

### 4. Boost.Asio 协程与执行模型（理解代码的关键）

项目大量使用 `net::awaitable<void>` + `co_await` 组织异步流程。

你需要知道几个关键词：

- `executor`：协程恢复执行的上下文（通常来自 `io_context`）。
- `co_spawn`：把一个协程任务投递到事件循环。
- `use_awaitable`：把异步操作转换为 `co_await` 的形式。
- `redirect_error`：把异常风格的错误改为写入 `error_code`（利于区分“正常收尾”与真正错误）。

#### 4.1 隧道阶段“正确退出”的策略

在双向转发时，最常见的坑是：A 方向已经结束（例如 `EOF`/对端关闭），但 B 方向仍阻塞在 `co_await` 的读写里，导致会话迟迟不退出，上游连接也无法及时回收。

ForwardEngine 的隧道阶段采用两层策略叠加，目标是“尽快收敛、稳定回收”：

- 正确转发：每次从源读取 `n` 字节，就只把 `n` 字节写到目标（避免把未使用的缓冲区内容误写出去）。
- 退出传播：当检测到“正常收尾”（例如 `EOF`、`operation_aborted`、`connection_reset` 等）时，会主动关闭对向 socket，让对向正在等待的异步读写尽快返回，从而两条方向协程能快速收敛。

`cancellation_signal/slot` 仍然适用于需要“软取消”的场景（例如某些协议封装层或显式超时控制）；但在纯 TCP 隧道里，“关闭对向”往往是更直接、可预期的退出手段。

### 5. Obscura（传输封装）与“伪装层”要点

Obscura 的思路可以粗略理解为：

- 外层表现为 WebSocket(SSL) 的握手与帧传输（基于 Beast）。
- 在握手阶段，客户端把目标信息放到某个约定的字段里（例如 path），服务端从握手结果解析出目标，然后建立到上游的连接。
- 握手完成后，WebSocket 连接在 SSL 之上变成一条“加密的二进制通道”，后续数据以 WebSocket 帧承载，不再出现传统 HTTP 的 header/method/url。

关于“伪装层”常见的现实约束：

- 对抗/伪装通常关注握手阶段可观察信息（例如 `SNI`）与流量特征（包大小、频率、时序等）。
- SSL 建立后内容不可见，但握手阶段的一些信息仍是明文可观察的，所以需要在“握手看起来像什么”与“后续流量像不像正常业务”上做文章。

### 6. 连接池与复用（为什么需要它）

建立 TCP 连接的成本不低（握手、系统资源、延迟）。项目提供了按目标端点缓存空闲连接的复用能力：

- 连接回收：使用 `internal_ptr` + 自定义 `deleter`，在智能指针析构时自动回收到池中。
- 健康检查：包含基础僵尸检测与空闲超时淘汰。
- 上限控制：避免单个端点无限积攒空闲连接。

### 7. 如何验证理解是否正确

最快的验证方式是跑测试并对照主链路：

- `session_test`：启动最小代理 + 上游回显/模拟上游断开，验证：
  - `CONNECT` 隧道是否按“读多少写多少”正确转发
  - 一端关闭后，另一端是否能及时被唤醒并收敛退出（避免卡住导致超时）
- `obscura_test`：验证 Obscura 握手、读写、关闭的基本链路。
- `connection_test`：验证连接复用是否命中，以及回收/淘汰是否符合预期。

#### 7.1 常见生命周期陷阱（回归重点）

- `io_context` 必须按 RAII 保证最后析构：任何 `socket`/连接池对象在析构时都可能触发关闭与回收逻辑，若 `io_context` 提前销毁，会出现访问违规。
- `detached` 协程禁止捕获栈引用：需要跨协程存活的对象必须放到 `std::shared_ptr`，否则主协程返回后后台协程访问悬空引用会导致崩溃。

